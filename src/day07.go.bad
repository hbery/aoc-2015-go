package hbery_aoc2015

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

func d07_toI(s string) int {
	val, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return int(val)
}

func d07_toI64(s string) int64 {
	val, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return val
}

func g_wire(s2v *map[string]uint16, src, dst string) error {
	if val, err := strconv.ParseUint(src, 10, 16); err != nil {
		(*s2v)[dst] = (*s2v)[src]
	} else {
		(*s2v)[dst] = uint16(val)
	}
	return nil
}

func g_not(s2v *map[string]uint16, src, dst string) error {
	if val, err := strconv.ParseUint(src, 10, 16); err != nil {
		(*s2v)[dst] = ^(*s2v)[src]
	} else {
		(*s2v)[dst] = ^uint16(val)
	}
	return nil
}

func g_and(s2v *map[string]uint16, srcA, srcB, dst string) error {
	var srcU16A, srcU16B uint16

	if val, err := strconv.ParseUint(srcA, 10, 16); err != nil {
		srcU16A = (*s2v)[srcA]
	} else {
		srcU16A = uint16(val)
	}

	if val, err := strconv.ParseUint(srcB, 10, 16); err != nil {
		srcU16B = (*s2v)[srcB]
	} else {
		srcU16B = uint16(val)
	}

	(*s2v)[dst] = srcU16A & srcU16B

	return nil
}

func g_or(s2v *map[string]uint16, srcA, srcB, dst string) error {
	var srcU16A, srcU16B uint16

	if val, err := strconv.ParseUint(srcA, 10, 16); err != nil {
		srcU16A = (*s2v)[srcA]
	} else {
		srcU16A = uint16(val)
	}

	if val, err := strconv.ParseUint(srcB, 10, 16); err != nil {
		srcU16B = (*s2v)[srcB]
	} else {
		srcU16B = uint16(val)
	}

	(*s2v)[dst] = srcU16A | srcU16B

	return nil
}

func g_lshift(s2v *map[string]uint16, src, bits, dst string) error {
	var srcU16 uint16
	var bitsI int

	if val, err := strconv.ParseUint(src, 10, 16); err != nil {
		srcU16 = (*s2v)[src]
	} else {
		srcU16 = uint16(val)
	}

	if val, err := strconv.ParseInt(bits, 10, 32); err != nil {
		return errors.New("Error: g_lshift::bits -> this should be integer, but cannot be parsed.")
	} else {
		bitsI = int(val)
	}

	(*s2v)[dst] = srcU16 << bitsI

	return nil
}

func g_rshift(s2v *map[string]uint16, src, bits, dst string) error {
	var srcU16 uint16
	var bitsI int

	if val, err := strconv.ParseUint(src, 10, 16); err != nil {
		srcU16 = (*s2v)[src]
	} else {
		srcU16 = uint16(val)
	}

	if val, err := strconv.ParseInt(bits, 10, 32); err != nil {
		return errors.New("Error: g_lshift::bits -> this should be integer, but cannot be parsed.")
	} else {
		bitsI = int(val)
	}

	(*s2v)[dst] = srcU16 >> bitsI

	return nil
}

func day07_p1(input string) (int64, error) {
	var sources2values = make(map[string]uint16)

	input = strings.TrimSuffix(input, "\n")

	// --- REGEX PHRASES COMPILATION --- //
	re_wire := regexp.MustCompile(`^(\d{1,5}|[a-z]{1,2}) -> (\d{1,5}|[a-z]{1,2})`)
	re_not := regexp.MustCompile(`^NOT (\d{1,5}|[a-z]{1,2}) -> (\d{1,5}|[a-z]{1,2})`)
	re_and := regexp.MustCompile(`^(\d{1,5}|[a-z]{1,2}) AND (\d{1,5}|[a-z]{1,2}) -> (\d{1,5}|[a-z]{1,2})`)
	re_or := regexp.MustCompile(`^(\d{1,5}|[a-z]{1,2}) OR (\d{1,5}|[a-z]{1,2}) -> (\d{1,5}|[a-z]{1,2})`)
	re_lshift := regexp.MustCompile(`^(\d{1,5}|[a-z]{1,2}) LSHIFT (\d{1,2}) -> (\d{1,5}|[a-z]{1,2})`)
	re_rshift := regexp.MustCompile(`^(\d{1,5}|[a-z]{1,2}) RSHIFT (\d{1,2}) -> (\d{1,5}|[a-z]{1,2})`)

	for _, line := range strings.Split(input, "\n") {
		if match := re_wire.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: wire, sources: %s, destination: %s\n", match[1], match[2])
			if err := g_wire(&sources2values, match[1], match[2]); err != nil {
				return -1, err
			}
			continue
		}

		if match := re_not.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: not, sources: %s, destination: %s\n", match[1], match[2])
			if err := g_not(&sources2values, match[1], match[2]); err != nil {
				return -1, err
			}
			continue
		}

		if match := re_and.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: and, sources: %s %s, destination: %s\n", match[1], match[2], match[3])
			if err := g_and(&sources2values, match[1], match[2], match[3]); err != nil {
				return -1, err
			}
			continue
		}

		if match := re_or.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: or, sources: %s %s, destination: %s\n", match[1], match[2], match[3])
			if err := g_or(&sources2values, match[1], match[2], match[3]); err != nil {
				return -1, err
			}
			continue
		}

		if match := re_lshift.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: lshift, sources: %s, destination: %s, args: %s\n", match[1], match[3], match[2])
			if err := g_lshift(&sources2values, match[1], match[2], match[3]); err != nil {
				return -1, err
			}
			continue
		}

		if match := re_rshift.FindStringSubmatch(line); match != nil {
			// fmt.Printf("op: rshift, sources: %s, destination: %s, args: %s\n", match[1], match[3], match[2])
			if err := g_rshift(&sources2values, match[1], match[2], match[3]); err != nil {
				return -1, err
			}
			continue
		}
	}

	fmt.Printf("%+v\n", sources2values)

	if val, exists := sources2values["a"]; !exists {
		return -1, errors.New("Error: There is no key `a` in the sources map.")
	} else {
		return int64(val), nil
	}

}

func day07_p2(input string) (int64, error) {
	return -1, nil
}

func Solution_Day07(part int, input string) (int64, error) {
	if part == 1 {
		return day07_p1(input)
	} else if part == 2 {
		return day07_p2(input)
	} else {
		return 0, errors.New(fmt.Sprintf("Error: Hold on cowboy. No such part (%d) of this day task", part))
	}
}
